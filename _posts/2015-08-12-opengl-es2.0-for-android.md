---
layout: post
title: "OpenGL ES2.0 for Android"
description: "android使用OpenGL ES2.0入门篇"
modified: 2015-08-12 22:21:38 +0800
tags: [android,openGL ES,animation]
image:
  feature: 
  credit: 
  creditlink: 
comments: false
share: false

---


今年年初在金立实习时，小组负责的吸色应用需要一个配套的动态壁纸，正好第一版动态壁纸内容很少而且任务很独立，就理所应当的分配给我这个刚入职的实习生了。

当时就了解了动态壁纸的机制和一些实现方法，大致有三种办法：通过surfaceView在canvas上连续绘制，通过GLsurfaceView绘制的OpenGL机制和原生动态壁纸使用的RenderScript。RenderScript好像很多接口没有开放，而且文档与demo少的可怜，OpenGL接触下发现绘制简单的正方形都要花很大的功夫，所以第一版就用了最简单的办法。

可是效率上却出现了问题，滑动桌面会出现掉帧现象。最后只好硬着头皮买了本OpenGL ES2.0的书开始啃，经过几个版本的迭代和慢慢的学习，现在也算是小小的入了个门，趁着还没有忘光，赶紧记录下来。

## OpenGL ES2.0概述

<!--more-->

OpenGL ES(OpenGL for Embedded Systems)是OpenGL三维图形API的子集，针对手机、PDA和游戏主机等嵌入式设备而设计。OpenGL ES 1.0针对固定管线硬件的，OpenGL ES 2.0针对可编程管线硬件，可以认为完全是两套API。最新3.0版本也在Android4.3得到了支持，从源码上看完全扩展自2.0，应该完全适用，暂不研究。

<!--more-->

**渲染管线**：渲染管线也称为渲染流水线，是显示芯片内部处理图形信号相互独立的的并行处理单元。大意就是在GPU中经过一系列的处理后生成显示在屏幕上的画面。

<figure class="half">
    <a href="http://7xl20x.com1.z0.glb.clouddn.com/es1.0.png">
    <img src="http://7xl20x.com1.z0.glb.clouddn.com/es1.0.png" alt="es1.0渲染管线"></a>
    <a href="http://7xl20x.com1.z0.glb.clouddn.com/es2.0.png">
    <img src="http://7xl20x.com1.z0.glb.clouddn.com/es2.0.png" alt="es2.0渲染管线"></a>
    <figcaption>两个版本渲染管线的区别</figcaption>
</figure>

OpenGL ES2.0与1.0最大的区别就是引入了可编程渲染管线，其中的顶点着色器和片元着色器代替了以前的变换，光照，纹理，颜色求和等，需要自己编程实现，大大提升灵活性。顾名思义顶点着色器处理多边形的顶点，片元着色器则处理多边形内每个片元，类似于像素点。着色器中使用的是着色语言GLSL，具有跨平台的特性，虽然OpenGL与OpenGL ES的着色语言有一点区别，但android，ios和web还是可以通用的。

## 着色语言

着色语言源自C语言，提供了丰富的原生类型，如向量、矩阵等，还有大量的内建函数，这在处理3D图形时可以更加高效、易用。

### 基本数据类型

*   标量
    GLSL中的标量含布尔、int和float，声明方法也跟一般的语言相似：
    
    ``` glsl
    bool b;
    int a = 15;
    int b = 0x3D;
    float f;
    float j, k = 2.56, l;
    ```

*   向量
    由2，3或4维标量组成：
    
    |   向量类型 |   说明   |   向量类型  |  说明   |
    |:----------:|:--------:|:-----------:|:-------:|
    | vec2 | 包含两个浮点的向量 | ivec2 | 包含两个整数的向量 |
    | vec3 | 包含三个浮点的向量 | bvec2 | 包含两个布尔的向量 |
    | vec4 | 包含四个浮点的向量 |   

    访问向量的某个分量可以通过数组下标`v[0]`访问，起始索引为0。也可以通过`.`+分量名来访问，根据目的GLSL中有三套分量名，分别为颜色`r,g,b,a`，坐标`x,y,z,w`和纹理坐标`s,t,p,q`，使用的时候三套分量名是相同作用的，只要同时使用时，保证为同一套即可：

    ``` glsl
    aColor.r = 0.6;
    aPosition.y = 2;
    aTexture.t = 0.65;
    aColor.xyz = vec3(0.5, 0.2, 0.6);
    ```

*   矩阵
    在3D场景中，矩阵是十分重要的，平移，旋转或者缩放都是靠矩阵运行实现的。所以GLSL中原生支持矩阵类型和相应的矩阵计算。

    |  矩阵类型 |   说明   |
    |:---------:|:--------:|
    | mat2 |  2*2浮点矩阵  | 
    | mat3 |  3*3浮点矩阵  | 
    | mat4 |  4*4浮点矩阵  | 

    矩阵可以看成由多个列向量组成，类似于二维数组，通过`m[0]`访问第一列向量，通过`m[0][0]`访问第一行第一列的值。

    > 从数学上看，矩阵可以看成多个列向量或者多个行向量组成，虽然两种选择功能相
    > 同，但是后续的变换计算是有所不同的。GLSL中是列向量，所以在做变换时，变换
    > 矩阵要左乘上位置坐标。

*   采样器
    一种特殊的基本数据类型，专门用来进行纹理采样的相关操作，我的理解采样器就是是一幅或一套纹理的引用，其值由宿主程序传入（Android即为Java）：

    |  采样器类型 |   说明   |
    |:-----------:|:--------:|
    | sampler2D   |  用于访问二维纹理  | 
    | sampler3D   |  用于访问三维纹理  | 
    | samplerCube |  用于访问立方体贴图纹理  | 

*   结构体
    类似于C语言中的结构体，声明方式同样使用struct关键字：

    ``` glsl
    struct vertex {
        vec3 position;
        vec3 color;
    }

    vertex v;   //声明vertex类型变量
    ```

*   数组
    跟C语言不太一样的时，数组声明的时候可以不指定长度，使用数组时也不用关心越界问题，编译器会自动创建适当大小的数组：

    ``` glsl
    vec3 position[];              //声明的时候可以不指定长度
    vec3 position[3]              //再次声明并制定长度后就不能再声明了
    position[3] = vec3(1.0, 1.0, 1.0);  //数组长度增长到4
    position[4] = vec3(1.0, 1.0, 1.0);  //数组长度增长到5
    ```

*   空类型
    使用`void`表示，用来声明不含返回值的函数，main函数就是例子。

### 基本语法

大部分语法都是跟C语言类似的，像变量声明、初始化，变量的作用域，运算符，if/else、for、while流程控制等都几乎是一样的，主要提一下不一样的地方。

*   系统许多的内建变量都是以`_gl`为开头的，所以用户自定义的变量不要使用这个做开头。
*   向量、矩阵初始化时各个元素既可以是字面常量也可以是变量：
   
    ``` glsl
    float a = 1.0;
    vec2 va = vec2(1.0, 1.0);              
    vec3 vb = vec3(v2, a);
    mat2 ma = mat2(1.0, 1.0, 1.0, a); 
    mat2 mb = mat2(va, 1.0, a);   
    mat2 mc = mat2(1.0);           
    ```

*   通过`.`可以混合选择向量的分量，并且可以重新排列：

    ``` glsl
    vec4 color = vec4(0.2, 0.2, 0.3, 0.2);
    vec3 temp1 = color.agr;
    vec4 temp2 = color.aagg;
    vec3 temp3;
    temp3.yxz = color.rgr;         
    ```

    同时使用时必须使用同一套分量名，像`color.xa`就是错误的用法。左值混合选择时不能有重复的分量名，但顺序可以改变，右值则可以任意搭配。

*   GLSL中对类型的匹配十分严格，没有类型自动转换的功能，左值右值的类型必须完全相同，类型的强制转换需要通过类似于构造函数的方式：

    ``` glsl
    float f = 1;          // 类型不匹配,会产生编译错误
    float f1 = 1.0;       
    bool b = bool(f1);    // 浮点转换为布尔,该构造函数会把非0值转换为false,0值转换为true
    float f2 = float(b);  // 布尔转换为浮点,会把true转换为1.0,false转换为0.0        
    ```
